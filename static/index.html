<!DOCTYPE html>
<html>
<head>
    <title>Chronic Reader Client</title>
    <link rel="manifest" href="manifest.json">
    <script src="/serviceworkerinstall.js"></script>
    <link rel="stylesheet" type="text/css" href="fonts.css">
    <script>
        class BookList {
            static SEED_MAX = parseInt("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16)
            constructor(element, withCollections = false, searchFunction = null) {
                this.element = element
                this.element.innerHTML = ""
                this.withCollections = withCollections
                this.searchFunction = searchFunction
            }

            createTitle(collection) {
                let title = document.createElement("h1")
                if (this.searchFunction != undefined && this.searchFunction != null) {
                    let items = this.getCollectionItems(collection)
                    for (let i of items) {
                        title.appendChild(i)
                    }
                } else {
                    title.innerHTML = collection
                }
                return title
            }

            createListElement() {
                let list = document.createElement('ul')
                list.style.padding = '0'
                list.style.listStyleType = 'none'
                list.style.display = 'grid'
                list.style.gridTemplateColumns = '30vw 30vw 30vw'
                list.style.columnGap = '2.5vw'
                list.style.rowGap = '2.5vw'
                return list
            }

            getListElement() {
                if (this.listElement == undefined) {
                    this.listElement = this.createListElement()
                    this.element.appendChild(this.listElement)
                }
                return this.listElement
            }

            getCollectionElement(collection) {
                if (this.collections == undefined) {
                    this.collections = new Map()
                }
                if (this.collections.has(collection)) {
                    return this.collections.get(collection).list
                } else {
                    let collectionTitle = this.createTitle(collection)
                    this.element.appendChild(collectionTitle)
                    let collectionList = this.createListElement()
                    this.element.appendChild(collectionList)
                    this.collections.set(collection, {
                        title: collectionTitle,
                        list: collectionList
                    })
                    return collectionList
                }
            }

            async addBook(book) {
                let parent = null
                if (this.withCollections) {
                    parent = this.getCollectionElement(book.collection)
                } else {
                    parent = this.getListElement()
                }

                let bookItem = await this.getBookItem(book)
                parent.appendChild(bookItem)
            }

            getProgressItem(book) {
                if (book.position) {
                    let progressEnclosure = document.createElement("span")
                    progressEnclosure.style.position = "relative"
                    progressEnclosure.style.width = "80%"
                    progressEnclosure.style.height = "5%"
                    progressEnclosure.style.top = "-10%"
                    progressEnclosure.style.left = "10%"
                    progressEnclosure.style.display = "inline-block"
                    progressEnclosure.style.backgroundColor = "white"
                    progressEnclosure.style.border = "1px solid black"

                    let progress = document.createElement("span")
                    progress.style.position = "absolute"
                    progress.style.display = "inline-block"
                    /*progress.style.margin = "10%"*/
                    progress.style.height = "80%"
                    progress.style.width = (99 * (book.position / book.size)) + "%"
                    progress.style.top = "10%"
                    progress.style.left = "1%"
                    progress.style.backgroundColor = "black"

                    progressEnclosure.appendChild(progress)
                    return progressEnclosure
                } else {
                    return null
                }
            }
            
            
            async getCoverItem(book) {
                let imageEnclosure = document.createElement("span")
                imageEnclosure.style.overflow = 'hidden'
                imageEnclosure.style.position = "relative"
                imageEnclosure.style.display = 'block'
                imageEnclosure.style.height = (8/5*30) + 'vw'

                let image = document.createElement("img")
                if (book.cover == null) {
                    image.src = await this.createBookCover(book.id, book.title, 500, 800)
                } else {
                    image.src = book.cover
                }
                image.onload = () => {
                    // center the image
                    image.style.top = (- (image.height - image.parentElement.offsetHeight) / 2) + "px"
                    image.style.left = (- (image.width - image.parentElement.offsetWidth) / 2) + "px"
                }
                image.style.height = '100%'
                image.style.position = "relative"
                imageEnclosure.appendChild(image)

                let progressItem = this.getProgressItem(book)
                if (progressItem != null) {
                    imageEnclosure.appendChild(progressItem)
                }

                return imageEnclosure
            }

            getIdSeed(id) {
                return parseInt(id, 16) / BookList.SEED_MAX
            }

            numToRgb(val) {
                let maxVal = 1
                let i = (val * 255 / maxVal)
                let r = Math.round(Math.sin(0.024 * i + 0) * 127 + 128)
                let g = Math.round(Math.sin(0.024 * i + 2) * 127 + 128)
                let b = Math.round(Math.sin(0.024 * i + 4) * 127 + 128)
                return [r, g, b]
            }

            computeLuminance(rgb) {
                let R = rgb[0]
                let G = rgb[1]
                let B = rgb[2]
                return Math.sqrt(0.299*R*R + 0.587*G*G + 0.114*B*B)
            }

            async createBookCover(id, title, width, height, element) {
                let margin = width / 10
                let words = title.split(/\s/g)
                let rows = []
                let row = ""
                let words_on_row = 3
                let longestRow = 0
                for (let i = 0; i < words.length; i++) {
                    if (i % words_on_row == 0) {
                        if (row.length > 0) {
                            rows.push(row)
                            if (row.length > rows[longestRow].length) longestRow = rows.length - 1
                        }
                        row = words[i]
                    } else {
                        row += " " + words[i]
                    }
                }
                if (row.length > 0) {
                    rows.push(row)
                    if (row.length > rows[longestRow].length) longestRow = rows.length - 1
                }

                const canvas = document.createElement('canvas')
                canvas.width = width
                canvas.height = height
                const context = canvas.getContext('2d')
                let colorSeed = this.getIdSeed(id)
                let coverRgb = this.numToRgb(colorSeed)
                let coverColor = `rgb(${coverRgb[0]},${coverRgb[1]},${coverRgb[2]})`
                let luminance = this.computeLuminance(coverRgb)
                let threshold = 140
                let textColor = "#000000"
                if (luminance < threshold) {
                    textColor = "#ffffff"
                }
                context.fillStyle = coverColor
                context.fillRect(0, 0, width, height)
                context.fillStyle = textColor
                context.textAlign = "center"

                // find correct font size
                //let f = new FontFace("Merriweather", 'url("/Merriweather/Merriweather-Regular.ttf")')
                //await f.load()

                let fontSize = width/rows[longestRow].length * 3
                context.font = fontSize + 'px "Merriweather"'
                while (context.measureText(rows[longestRow]).width > width - margin) {
                    fontSize -= 1
                    // font-family: 'Merriweather', serif;
                    context.font = fontSize + 'px "Merriweather"'
                }

                let rowHeight = 0
                //let totalHeight = 0
                for (let i = 0; i < rows.length; i++) {
                    let tm = context.measureText(rows[i])
                    //console.log(tm)
                    let height = tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent
                    //totalHeight += height
                    if (height > rowHeight) rowHeight = height
                }
                //console.log(rowHeight)
                let rowSpacing = 10
                rowHeight = rowHeight + rowSpacing
                let totalHeight = rowHeight * rows.length

                for (let i = 0; i < rows.length; i++) {
                    let h = (height/2) - (totalHeight/2) + (i+1) * rowHeight// + rowHeight / 2
                    context.fillText(rows[i], width/2, h)
                }
                
                let base64 = canvas.toDataURL() 
                
                if (element) {
                    let img = document.createElement('img')
                    img.src = base64
                    element.appendChild(img)
                }

                return base64
            }

            getCollectionItems(collection) {
                console.log(collection)
                if (collection == undefined || collection == null || collection.length == 0) return []
                if (this.searchFunction != undefined && this.searchFunction != null) {
                    let collectionParts = collection.split("/").filter(e => e.length > 0)
                    let cumulative = ""
                    let items = []
                    for (let part of collectionParts) {
                        let partName = "/" + part
                        let partSearch = cumulative + partName

                        let collectionItem = document.createElement("a")
                        collectionItem.innerHTML = partName
                        collectionItem.onclick = () => this.searchFunction(partSearch)
                        items.push(collectionItem)

                        cumulative = partSearch
                    }

                    return items
                } else {
                    let collectionItem = document.createElement("span")
                    collectionItem.innerHTML = collection
                    return [collectionItem]
                }
            }

            getBookLink(book) {
                return "/read.html?book=" + book.id
            }

            async getBookItem(book) {
                let item = document.createElement("li")
                item.style.width = '100%'
                item.style.overflow = 'hidden'

                let itemLink = document.createElement("a")
                itemLink.style.overflow = 'hidden'
                itemLink.style.position = 'relative'
                itemLink.href = this.getBookLink(book)
                
                itemLink.appendChild(await this.getCoverItem(book))
                item.appendChild(itemLink)

                if (this.withCollections == false) {
                    let title = document.createElement("span")
                    let items = this.getCollectionItems(book.collection)
                    for (let i of items) {
                        title.appendChild(i)
                    }
                    if (items.length > 0) {
                        let slash = document.createElement("span")
                        slash.innerHTML = "/"
                        title.appendChild(slash)
                    }
                    let actualTitle = document.createElement("a")
                    actualTitle.innerHTML = book.title
                    actualTitle.href = this.getBookLink(book)
                    title.appendChild(actualTitle)
                    item.appendChild(title)
                } else {
                    let title = document.createElement("a")
                    title.innerHTML = book.title
                    title.href = this.getBookLink(book)
                    item.appendChild(title)
                }
                
                
                return item
            }
        }
        
        /*function getBookList(books) {
            let list = document.createElement('ul')
            list.style.padding = '0'
            list.style.listStyleType = 'none'
            list.style.display = 'grid'
            list.style.gridTemplateColumns = '30vw 30vw 30vw'
            list.style.columnGap = '2.5vw'
            list.style.rowGap = '2.5vw'

            for (let i = 0; i < books.length; i++) {
                let item = getBookItem(books[i])
                list.appendChild(item)
            }

            return list
        }*/
        
        window.onload = function() {
            fetch("/books")
            .then(response => {
                return response.json()
            })
            .then((books) => {
                let list = new BookList(document.getElementById("localList"))
                for (let book of books) {
                    list.addBook(book)
                }
            })
            /*fetch("search")
            .then(response => {
                console.log(response)
                return response.json()
            })
            .then(searchResult => {
                let searchList = document.getElementById("searchList")
                searchList.innerHTML = ""
                searchList.appendChild(getBookList(searchResult))
            })*/
            document.getElementById("searchForm").onsubmit()
            new Search(document.getElementById("latestReadList"), "", 5, Search.ORDER_LATEST_READ, false).firstSearch()
            new Search(document.getElementById("latestAddedList"), "", 5, Search.ORDER_LATEST_ADDED, false).firstSearch()
            //createBookCover("A book about political science and all other stupid shit that has a ridiculously long title", 300, 500, document.getElementById("testCover"))
        }

        class Search {
            static ORDER_LATEST_READ = "read"
            static ORDER_LATEST_ADDED = "added"
            static ORDER_TITLE = ""
            constructor(element, term, pageSize, order, multipage) {
                this.element = element
                this.term = term
                this.pageSize = pageSize
                this.order = order
                this.multipage = multipage
            }

            getUrl() {
                return "search?" + new URLSearchParams({
                    term: this.term,
                    page: this.page,
                    pageSize: this.pageSize,
                    order: this.order
                }) 
            }

            addBooksToResult(books) {
                if (this.nextPage) {
                    this.nextPage.remove()
                    this.nextPage = null
                }
                for (let book of books) {
                    this.bookList.addBook(book)
                }
                if (this.multipage) {
                    if (books.length == this.pageSize) {
                        this.nextPage = document.createElement("a")
                        this.nextPage.innerHTML = "next"
                        this.nextPage.onclick = () => this.nextSearch()
                        this.element.appendChild(this.nextPage)
                    }
                }
            }

            runSearch() {
                fetch(this.getUrl())
                .then(response => {
                    //console.log(response)
                    return response.json()
                })
                .then(searchResult => {
                    //console.log(searchResult)
                    this.addBooksToResult(searchResult)
                })
            }

            firstSearch() {
                let withCollectionSections = (this.order == Search.ORDER_TITLE)
                this.bookList = new BookList(this.element, withCollectionSections/*, (term) => console.log("searching " + term)*/)
                this.page = 0
                this.runSearch()
            }

            nextSearch() {
                this.page = this.page + 1
                this.runSearch()
            }
        }
        function searchForm(form) {
            try {
                let data = new FormData(form)
                let term = data.get("term")
                document.search = new Search(document.getElementById("searchList"), term, 5, Search.ORDER_TITLE, true)
                document.search.firstSearch()
            } catch (error) {
                console.log(error)
            }
            return false
        }
    </script>
    
    <style>
        body {
            font-family: 'Merriweather', serif;
            font-size: 1.5rem;
        }
        a {
            color: black;
            text-decoration: underline;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Chronic Reader Client</h1>
    <div id="testCover"></div>
    <div id="localList"></div>
    <form action="upload" enctype="multipart/form-data" method="post">
        <label for="myFile">Upload Your File</label>
        <input id="myFile" accept=".epub,.cbz,.cbr" name="filename" type="file" />
        <button name="submit" type="submit">Upload File</button>
    </form>
    <form action="login" method="post">
        <label for="server">Server</label><input name="server" type="text" />
        <label for="username">Username</label><input name="username" type="text" />
        <label for="password"></label><input name="password" type="password" />
        <button name="submit" type="submit">Login</button>
    </form>
    <h1>Latest read</h1>
    <div id="latestReadList"></div>
    <h1>Latest added</h1>
    <div id="latestAddedList"></div>

    <form id="searchForm" onsubmit="return searchForm(this);">
        <label for="term">term:</label><input name="term" type="text" />
        <button name="submit" type="submit">Search</button>
    </form>
    <div id="searchList"></div>
    
</body>
</html>